on getPath()	tell application "System Events"		if exists (processes where name is "DEVONthink 3") then			try				set mSelection to my getSelection("any")			on error msg				return msg			end try						set the clipboard to path of mSelection as string			return "✓ Copied to clipboard: " & path of mSelection as string		else			return "DNtp is not running"		end if	end tell	return "✗ unkown error occured"end getPathon runViewer()	-- This is the main function for opening viewers.	-- It uses 3 environment variables to configure its behaviour.	tell application "System Events"		if exists (processes where name is "DEVONthink 3") then			set mViewer to (system attribute "viewer")			try				set mSelection to my getMultiTypeSelection(system attribute "content_type")			on error msg				return msg			end try						set mFilePath to quoted form of (path of mSelection as string)			if mViewer ≠ "" then				set mCmd to "open -a '" & mViewer & "' " & mFilePath & "; echo $?"			else				set mCmd to "open " & mFilePath & "; echo $?"			end if			set mSuccess to (do shell script mCmd) as number			if mSuccess = 0 then				return			else				return "✗ Couldn't open file; is the viewer set correctly?"			end if		else			return "DNtp is not running"		end if	end tell	return "✗ unkown error occured"end runVieweron runDNtpNote()	-- This is the main function for creating notes of PDFs	tell application "System Events"		if exists (processes where name is "DEVONthink 3") then			tell application id "DNtp"				try					set mSelection to my getMultiTypeSelection(system attribute "content_type")				on error msg					return msg				end try								set mDb to database of mSelection				set mParent to my parentOf(mSelection)				set mNotesGrp to my getGrp(mParent, "pdf notes")				set mRecName to name of mSelection & ".markdown"				set mRecord to my getChild(mNotesGrp, mRecName, mSelection)				if mRecord = missing value then					set mRecord to my newMarkdown(mRecName, mSelection, mNotesGrp)				end if				if mRecord ≠ missing value then					set mPath to quoted form of (path of mRecord as string)					set mCmd to "open " & " " & mPath & "; echo $?"					tell me to set mSuccess to (do shell script mCmd) as number					if mSuccess = 0 then						return					else						return "✗ Couldn't open file"					end if				else					return "✗ couldn't find or create markdown"				end if			end tell		else			return "✗ DNtp is not running"		end if	end tell	return "✗ unkown error occured"end runDNtpNoteon runSetDNtpNote()	tell application "System Events"		if exists (processes where name is "DEVONthink 3") then			tell me				try					try						set mSelection to my getMultiTypeSelection(system attribute "content_type")					on error msg						return msg					end try					display alert "Select notes markdown file in DNtp"					set mMdSel to getSelection("markdown")					set mParent to my parentOf(mSelection)					set mNotesGrp to my getGrp(mParent, "pdf notes")					setUrl(mSelection, mMdSel)					tell application id "DNtp" to move record mMdSel to mNotesGrp					return				on error msg					return msg				end try			end tell		else			return "✗ DNtp is not running"		end if	end tell	return "✗ unkown error occured"end runSetDNtpNote-- Below is library code for runDNtpNote()on splitStr(someText, delimiter)	set AppleScript's text item delimiters to delimiter	set someText to someText's text items	set AppleScript's text item delimiters to {""} --> restore delimiters to default value	return someTextend splitStron getMultiTypeSelection(mKinds)	repeat with mType in my splitStr(mKinds, ";")		try			set mSelection to my getSelection(mType)			log "Correct type: " & (path of mSelection as string)			exit repeat		on error			set mSelection to missing value		end try	end repeat	if mSelection = missing value then		error "✗ select a file of kind " & mKinds	end if	return mSelectionend getMultiTypeSelectionon getSelection(mKind)	tell application "System Events"		if exists (processes where name is "DEVONthink 3") then			tell application id "DNtp"				if (count of selection) = 0 then					error "✗ nothing selected"				else if (count of selection) > 1 then					error "✗ more than 1 selected"				end if				set mSelection to selection				set mSelection to the first item of mSelection				if kind of mSelection ≠ (mKind as text) and mKind ≠ "any" then					error "✗ select a file of kind " & mKind & "; current selection is: " & filename of mSelection & " of type: " & kind of mSelection				end if				return mSelection			end tell		end if	end tellend getSelectionon getGrp(mParent, mGrpName)	tell application id "DNtp"		repeat with mChild in children of mParent			if name of mChild = mGrpName and type of mChild = group then				return mChild			end if		end repeat		return create record with {filename:mGrpName, name:mGrpName, type:group} in mParent	end tellend getGrpon getUrl(mSelection)	tell application id "DNtp"		set mUrl to URL of mSelection		if length of mUrl = 0 then			return missing value		end if		set mProto to "x-devonthink-item://"		set mProtoLen to length of mProto		set mProtoFnd to missing value		if length of mUrl is less than mProtoLen then			set mProtoFnd to mUrl		else			set mProtoFnd to texts 1 thru mProtoLen of mUrl		end if		if mProtoFnd = mProto then			set mUuid to texts (mProtoLen + 1) thru -1 of mUrl			set mRecord to get record with uuid mUuid			if mRecord = missing value or type of mRecord ≠ markdown then				return missing value			else				return mRecord			end if		else			return missing value		end if	end tellend getUrlon getChild(mParent, mChildName, mSelection)	tell application id "DNtp"		set mUrlLookup to my getUrl(mSelection)		if mUrlLookup ≠ missing value then			return mUrlLookup		end if		repeat with mChild in children of mParent			if name of mChild = mChildName and type of mChild = markdown then				return mChild			end if		end repeat		return missing value	end tellend getChildon parentOf(mContent)	tell application id "DNtp"		set mParent to missing value		if (count of parents of mContent) = 1 then			set mParent to first item of parents of mContent		else if (count of parents of mContent) > 1 then			set mPrntNames to {}			repeat with i from 1 to count of parents of mContent				set end of mPrntNames to name of item i of (parents of mContent)			end repeat			set mChoices to choose from list mPrntNames with prompt "Choose parent:" default items (first item of mPrntNames) without empty selection allowed			set prntChoice to item 1 of mChoices			repeat with i from 1 to count of parents of mContent				set mCandidate to item i of (parents of mContent)				if name of mCandidate = prntChoice then					set mParent to mCandidate				end if			end repeat		end if		return mParent	end tellend parentOfon newMarkdown(mRecName, mSelection, mParent)	tell application id "DNtp"		set mTitle to ""		if name of mSelection ≠ missing value and name of mSelection ≠ "" then			set mTitle to name of mSelection		else			set mTitle to filename of mSelection		end if		set mMkDwn to create record with {filename:mRecName, name:mRecName, type:markdown, plain text:"#" & mTitle} in mParent		set mUrl to reference URL of mMkDwn		set URL of mSelection to mUrl		return mMkDwn	end tellend newMarkdownon setUrl(mFrom, mTo)	tell application id "DNtp"		set mUrl to reference URL of mTo		set URL of mFrom to mUrl	end tellend setUrl